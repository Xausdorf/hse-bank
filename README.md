# КПО: Домашнее задание #2. Паттерны проектирования

Консольное приложение для учета финансов

## Описание
Приложение позволяет создавать, обновлять, удалять, просматривать банковские счета, категории операций, операции. 

Также он позволяет сохранять данные в файл в формате JSON и YAML и импортировать из таких файлов.

В `domain` описаны интерфейсы и структуры, их конструкторы, методы доступа к приватным полям.

В `command` описаны команды для паттерна "Команда". Там же реализован декоратор для логирования выполнения команд.

В `facade` фасады для работы с объектами для паттерна "Фасад".

В `file` инкапсулирована работа с файлами для экспорта и импорта данных.

В `service` описан сам сервис учета финансов.

В `repository` написано упрощенное in-memory хранилище данных реализующее паттерн "Репозиторий". 

В `tui` написаны структуры для TUI в консоли с помощью фреймворка [Bubble Tea](https://github.com/charmbracelet/bubbletea).

В `cmd/tui/main.go` используется DI-контейнер из библиотеки [uber-go/dig](https://github.com/uber-go/dig), в него передаются все зависимости в виде конструкторов и затем запускается метод `Run` запускающий TUI. Логирование происходит в файл создаваемый в этом файле.

## Принципы SOLID
### Принцип единственной ответственности
Реализуется, например, обработчиками команд из пакета [internal/command](internal/command/), каждый из них ответственен только за обработку единственной команды.

### Принцип открытости-закрытости
Репозитории описаны как интерфейсы в [internal/facade/facade.go](internal/facade/facade.go) и могут быть реализованы например в виде PostgreSQL базы данных, для этого достаточно будет написать новую реализацию в `internal/repository/postgres` и передавать новую реализацию в DI контейнер в `cmd/tui/main.go`.

### Принцип подстановки Барбары Лисков
В проекте интерфейсы репозиториев [internal/facade/facade.go](internal/facade/facade.go) реализованы таким образом, что любая их реализация (in-memory, PostgreSQL и т.д.) может быть использована без изменения поведения программы. Также все обработчики команд в [internal/command](internal/command/) реализуют интерфейс `CommandHandler` и могут быть взаимозаменяемы в обработчике команд.

### Принцип разделения интерфейсов
В [internal/facade/facade.go](internal/facade/facade.go) интерфейсы разделены на более мелкие специализированные: `BankAccountRepository`, `CategoryRepository` и `OperationRepository`, вместо одного большого интерфейса. Это позволяет клиентам зависеть только от тех методов, которые им действительно нужны.

### Принцип инверсии зависимостей
Все зависимости в проекте определены через интерфейсы, а не конкретные реализации. Например, сервис в [internal/service/service.go](internal/service/service.go) зависит от интерфейсов репозиториев, а не их конкретных реализаций. Внедрение зависимостей осуществляется через DI-контейнер в [cmd/tui/main.go](cmd/tui/main.go).

## Принципы GRASP

### Information Expert
Фасады в [internal/facade](internal/facade/) являются экспертами по работе с соответствующими сущностями, так как именно они содержат всю логику валидации и преобразования данных для банковских счетов, категорий и операций.

### Creator
Фабрика в [internal/factory/bank.go](internal/factory/bank.go) отвечает за создание сущностей домена, так как она имеет всю необходимую информацию для их инициализации и обеспечивает их корректное состояние.

### Controller
Паттерн Controller реализован в виде обработчиков команд в [internal/command](internal/command/), которые инкапсулируют логику обработки конкретных операций и делегируют выполнение соответствующим объектам.

### Low Coupling
Использование фасадов и интерфейсов репозиториев обеспечивает низкую связанность между компонентами. Например, изменение реализации хранения данных не повлияет на бизнес-логику или UI.

### High Cohesion
Каждый пакет имеет четко определенную ответственность: `repository` отвечает за хранение данных, `service` за бизнес-логику, `command` за обработку команд, что обеспечивает высокую связность внутри каждого модуля.

### Protected Variations
Использование интерфейсов для репозиториев и команд, а также фасадов защищает от изменений в конкретных реализациях. Например, добавление новой реализации репозитория не потребует изменений в остальном коде.

## Паттерны GoF
Реализованы 8 паттернов GoF.

### Фасад
Реализован в пакете [internal/facade](internal/facade/). В фасады упакована вся работа с конкретными объектами. Благодаря этому представляется простой интерфейс для сложных подсистем.

### Команда
Реализован в пакете [internal/command](internal/command/). Каждый пользовательский сценарий упакован в команду.

### Декоратор
Реализован в [internal\command\handler.go](internal\command\handler.go) в виде декоратора для логирования обработки команд. Позволяет один раз написать логику логирования а затем просто оборачивать обработчики в декоратор не изменяя интерфейса.

### Шаблонный метод
Реализован в [internal\file\import.go](internal\file\import.go) для импорта данных общим кодом, меняя только один шаблонный метод `unmarshalFileData` для парсинга различных форматов. Конкретные реализации представлены в [internal\file\json.go](internal\file\json.go) и [internal\file\yaml.go](internal\file\yaml.go).

### Стратегия
Реализован в [internal\file\export.go](internal\file\export.go) в виде интерфейса стратегии `MarshalVisitor`. Таким образом конкретные стратегии из [internal\file\json.go](internal\file\json.go) и [internal\file\yaml.go](internal\file\yaml.go) могут быть взаимозаменяемы прямо во время исполнения программы.

### Посетитель
Реализован в [internal\file\visitor.go](internal\file\visitor.go). Позволяет экспортировать данные в нужный файл не меняя сами объекты (`BankAccount`, `Category`, `Operation`).

### Фабрика
Реализован в [internal\factory](internal\factory). Вся логика создания и валидации объектов доменных классов происходит только в нем, что позволяет избежать дублирования кода.

### Синглтон
Реализован в [cmd\tui\main.go](cmd\tui\main.go) через DI контейнер. Классы создаются только один раз и работа происходит только с одним инстансом.

## Инструкция по запуску 
Необходима версия Go >= 1.24.0 и версия тулчейна Go >= 1.24.10.

Для запуска из корневой папки проекта
```
go run ./cmd/tui/main.go
```

Лучше запускать в достаточно большом терминале, иначе некоторые таблицы могут быть не видны полностью.